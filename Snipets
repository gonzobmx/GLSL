//----------------GRADIENT----------------//

{
    vec2 xy = fragCoord.xy; //We obtain our coordinates for the current pixel
    
    //We divide the coordinates by the screen size
    float a = float(1.0);// change position of the gradient
    xy.x = xy.x / iResolution.x*(a); 
    xy.y = xy.y / iResolution.y*(a);  
    
    
    // Now x is 0 for the leftmost pixel, and 1 for the rightmost pixel
    vec4 solidRed = vec4(0,0.0,0.0,1.0); //This is actually black right now
    
    //Set its red component to the normalized x value  
    solidRed.r = xy.y; //Left to right
    solidRed.r = xy.x; //Top to Bottom
    
    //solidRed.r = 1.0-xy.y;//FLIP
    
    fragColor = solidRed;
}


//----------------TEXTURE----------------//

{
    vec2 xy = fragCoord.xy / iResolution.xy;//Condensing this into one line
    vec4 solidBlack = vec4(0,0.0,0.0,1);
    //Get the pixel at xy from iChannel0
    vec4 texColor = texture(iChannel0,xy*(1.0))*(0,0,0,xy.y); // Mulitply coordinates to achive tiling and to make gradient
//    texColor = (texColor.r,texColor.g,texColor.b, xy.x);
    
    fragColor = texColor;
}

//----------------Time----------------//
vec4 texColor = vec4(abs(sin(iTime))); // multiplying time to color


//---------------Step----------------//

{
  vec2 uv = fragCoord/iResolution.xy; // <0,1>

  vec3 col = vec3(0); // start with black
  
  col = vec3(step(abs(cos(iTime*0.1))*0.5, uv.x)); // make the right half of the canvas white

  // Output to screen
  fragColor = vec4(col,1.0);
}

//---------------Circle----------------//

vec3 sdfCircle(vec2 uv, float r) {
    float x = uv.x;
    float y = uv.y;
    
    float d = length(vec2(x, y)) - r;
    
    return d < 0. ? vec3(1.) : vec3(0., 0., 1.);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
  vec2 uv = fragCoord/iResolution.xy; // <0,1>
  
  
  
  uv -= 0.5; // to center sircle 
  uv.x *= iResolution.x/iResolution.y; // fixing aspect ratio
  
  vec3 col = sdfCircle(uv, .2); // Call this function on each pixel to check if the coordinate lies inside or outside of the circle

  // Output to screen
  fragColor = vec4(col,1.0);
}



//---------------Rotating Square----------------//

vec2 rotate (vec2 uv, float th){
return mat2(cos(th), sin(th), -sin(th), cos(th))*uv; //The first two values -
// first column,  last two values - second.
}

vec3 sdfSqr(vec2 uv, float r) {
    float x = uv.x;
    float y = uv.y;
    
    vec2 rotated = rotate(vec2(x,y), iTime);
    
    float d = max(abs(rotated.x),abs(rotated.y))-r;
    
    return d < 0. ? vec3(0.) : vec3(1., 1., 1.);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
  vec2 uv = fragCoord/iResolution.xy; // <0,1>
  
  
  
  uv -= 0.5; // to center sircle 
  uv.x *= iResolution.x/iResolution.y; // fixing aspect ratio
  
  vec3 col = sdfSqr(uv, .4); // Call this function on each pixel to check if the coordinate lies inside or outside of the circle

  // Output to screen
  fragColor = vec4(col,1.0);
}
